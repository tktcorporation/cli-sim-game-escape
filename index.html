<!doctype html>
<html lang="ja">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
    <link data-trunk rel="rust" />
    <title>Idle Games - 放置ゲーム</title>
    <style>
      body {
        margin: 0;
        width: 100%;
        height: 100vh;
        height: 100dvh;
        background-color: #0a0a0a;
        overflow: hidden;
        touch-action: manipulation;
        -webkit-tap-highlight-color: transparent;
      }
      body > div {
        margin: 0;
        width: 100%;
      }
      pre {
        font-family: "Fira Code", "Courier New", monospace;
        font-size: 14px;
        /* Ratzilla sets inline height:15px which clips text when font is
           scaled up.  Let the row height follow the actual font size. */
        height: auto !important;
        line-height: 1.15;
        margin: 0;
        padding: 0;
        touch-action: manipulation;
        cursor: default;
      }
    </style>
  </head>
  <body></body>
  <script>
    // Reduce the viewport dimensions reported to Ratzilla so it calculates
    // fewer terminal columns/rows, resulting in larger text that fills the
    // real viewport via the fitGridToViewport scaler below.
    // SCALE < 1 → bigger text.  0.85 ≈ 18 % larger characters.
    (function() {
      var SCALE = 0.85;

      function override(obj, proto, prop) {
        var desc = Object.getOwnPropertyDescriptor(proto, prop);
        if (desc && desc.get) {
          var orig = desc.get;
          Object.defineProperty(obj, prop, {
            get: function() { return Math.floor(orig.call(obj) * SCALE); },
            configurable: true
          });
        }
      }

      // Override both width and height so Ratzilla creates fewer
      // columns AND rows.  fitGridToViewport() scales font to fill the
      // viewport width; with height:auto on <pre>, rows grow taller.
      // Without the height override the grid overflows on mobile.
      override(window, Window.prototype, 'innerWidth');
      override(window, Window.prototype, 'innerHeight');
      override(screen, Screen.prototype, 'width');
      override(screen, Screen.prototype, 'height');
    })();
  </script>
  <script>
    // Ratzilla calculates terminal columns as screen_width/10 (mobile) or
    // window.innerWidth/10 (desktop), assuming ~10px per character. When the
    // actual rendered character width differs from 10px the grid becomes
    // narrower than the viewport. This observer waits for Ratzilla to mount
    // its grid, measures the real content width, and scales the font so the
    // grid fills the viewport exactly.
    (function() {
      var applied = false;
      var lastViewportWidth = 0;

      function applyFontSize(preElements, fontSize) {
        var px = Math.floor(fontSize * 100) / 100 + 'px';
        for (var i = 0; i < preElements.length; i++) {
          preElements[i].style.fontSize = px;
        }
      }

      function fitGridToViewport() {
        var grid = document.getElementById('grid') || document.querySelector('body > div');
        if (!grid) return false;
        var pre = grid.querySelector('pre');
        if (!pre) return false;

        var viewportWidth = document.documentElement.clientWidth;
        var viewportHeight = document.documentElement.clientHeight;

        // <pre> is a block element so scrollWidth always equals the
        // container width, not the actual text width.  Temporarily switch
        // to inline-block so the element shrink-wraps to its content,
        // then measure with getBoundingClientRect for sub-pixel accuracy.
        pre.style.display = 'inline-block';
        var contentWidth = pre.getBoundingClientRect().width;
        pre.style.display = '';

        if (contentWidth <= 0 || contentWidth >= viewportWidth) return true;

        var currentFontSize = parseFloat(getComputedStyle(pre).fontSize);
        var widthScale = viewportWidth / contentWidth;
        var scaledFontSize = currentFontSize * widthScale;

        var preElements = document.querySelectorAll('pre');
        applyFontSize(preElements, scaledFontSize);

        // After width-fitting, check if grid overflows viewport height.
        // With height:auto on <pre>, larger font → taller rows → overflow.
        var gridHeight = grid.offsetHeight;
        if (gridHeight > viewportHeight + 2) {
          var heightScale = viewportHeight / gridHeight;
          scaledFontSize = scaledFontSize * heightScale;
          applyFontSize(preElements, scaledFontSize);
        }

        applied = true;
        lastViewportWidth = viewportWidth;
        return true;
      }

      // Observe DOM for Ratzilla grid mount, then fit once.
      var observer = new MutationObserver(function() {
        if (fitGridToViewport()) observer.disconnect();
      });
      observer.observe(document.body, { childList: true, subtree: true });

      // Re-fit on orientation change or resize (debounced).
      var resizeTimer;
      window.addEventListener('resize', function() {
        clearTimeout(resizeTimer);
        resizeTimer = setTimeout(function() {
          var vw = document.documentElement.clientWidth;
          if (vw !== lastViewportWidth) {
            // Reset to CSS default so measurement is from a clean state.
            var preElements = document.querySelectorAll('pre');
            for (var i = 0; i < preElements.length; i++) {
              preElements[i].style.fontSize = '';
            }
            applied = false;
            // Allow one frame for layout, then re-measure.
            requestAnimationFrame(function() { fitGridToViewport(); });
          }
        }, 150);
      });
    })();

    // Touch handler: convert touch events to synthetic mousedown events.
    // This lets Ratzilla's on_mouse_event handler (registered in Rust) process
    // taps through the same ClickState hit-test path as desktop clicks.
    //
    // We dispatch a synthetic mousedown instead of handling touch in WASM because
    // web-sys TouchEvent/Touch/TouchList causes iOS Safari's WebKit WASM engine
    // to render a black screen (discovered in commit 0caf982).
    (function() {
      document.addEventListener('touchstart', function(e) {
        if (e.touches.length === 0) return;
        var touch = e.touches[0];
        // Dispatch a synthetic mousedown so Ratzilla's on_mouse_event fires
        document.dispatchEvent(new MouseEvent('mousedown', {
          clientX: touch.clientX,
          clientY: touch.clientY,
          button: 0,
          bubbles: true
        }));
      }, { passive: true });
    })();
  </script>
</html>
