<!doctype html>
<html lang="ja">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
    <link data-trunk rel="rust" />
    <title>Idle Games - 放置ゲーム</title>
    <style>
      body {
        margin: 0;
        width: 100%;
        height: 100vh;
        height: 100dvh;
        background-color: #0a0a0a;
        overflow: hidden;
        touch-action: manipulation;
        -webkit-tap-highlight-color: transparent;
      }
      body > div {
        margin: 0;
        width: 100%;
      }
      pre {
        font-family: "Fira Code", "Courier New", monospace;
        font-size: 14px;
        margin: 0;
        padding: 0;
        touch-action: manipulation;
        cursor: default;
      }
    </style>
  </head>
  <body></body>
  <script>
    // Reduce the viewport dimensions reported to Ratzilla so it calculates
    // fewer terminal columns/rows, resulting in larger text that fills the
    // real viewport via the fitGridToViewport scaler below.
    // SCALE < 1 → bigger text.  0.85 ≈ 18 % larger characters.
    (function() {
      var SCALE = 0.85;

      function override(obj, proto, prop) {
        var desc = Object.getOwnPropertyDescriptor(proto, prop);
        if (desc && desc.get) {
          var orig = desc.get;
          Object.defineProperty(obj, prop, {
            get: function() { return Math.floor(orig.call(obj) * SCALE); },
            configurable: true
          });
        }
      }

      override(window, Window.prototype, 'innerWidth');
      override(window, Window.prototype, 'innerHeight');
      override(screen, Screen.prototype, 'width');
      override(screen, Screen.prototype, 'height');
    })();
  </script>
  <script>
    // Ratzilla calculates terminal columns as screen_width/10 (mobile) or
    // window.innerWidth/10 (desktop), assuming ~10px per character. When the
    // actual rendered character width differs from 10px the grid becomes
    // narrower than the viewport. This observer waits for Ratzilla to mount
    // its grid, measures the real content width, and scales the font so the
    // grid fills the viewport exactly.
    (function() {
      var applied = false;
      var lastViewportWidth = 0;

      function fitGridToViewport() {
        var grid = document.getElementById('grid') || document.querySelector('body > div');
        if (!grid) return false;
        var pre = grid.querySelector('pre');
        if (!pre) return false;

        var viewportWidth = document.documentElement.clientWidth;
        var contentWidth = pre.scrollWidth;
        if (contentWidth <= 0 || contentWidth >= viewportWidth) return true;

        var currentFontSize = parseFloat(getComputedStyle(pre).fontSize);
        var scaledFontSize = Math.floor(currentFontSize * (viewportWidth / contentWidth) * 100) / 100;
        var preElements = document.querySelectorAll('pre');
        for (var i = 0; i < preElements.length; i++) {
          preElements[i].style.fontSize = scaledFontSize + 'px';
        }
        applied = true;
        lastViewportWidth = viewportWidth;
        return true;
      }

      // Observe DOM for Ratzilla grid mount, then fit once.
      var observer = new MutationObserver(function() {
        if (fitGridToViewport()) observer.disconnect();
      });
      observer.observe(document.body, { childList: true, subtree: true });

      // Re-fit on orientation change or resize (debounced).
      var resizeTimer;
      window.addEventListener('resize', function() {
        clearTimeout(resizeTimer);
        resizeTimer = setTimeout(function() {
          var vw = document.documentElement.clientWidth;
          if (vw !== lastViewportWidth) {
            // Reset to CSS default so measurement is from a clean state.
            var preElements = document.querySelectorAll('pre');
            for (var i = 0; i < preElements.length; i++) {
              preElements[i].style.fontSize = '';
            }
            applied = false;
            // Allow one frame for layout, then re-measure.
            requestAnimationFrame(function() { fitGridToViewport(); });
          }
        }, 150);
      });
    })();

    // Standard click handler: parse action keys from clicked <pre> text content
    // and dispatch corresponding keyboard events for ratzilla's on_key_event handler.
    function handleClickOrTap(clientX, clientY) {
      var el = document.elementFromPoint(clientX, clientY);
      if (!el) return;
      // Walk up to find a <pre> element (ratzilla renders each row as <pre>)
      while (el && el.tagName !== 'PRE') {
        el = el.parentElement;
      }
      if (!el) return;
      var text = el.textContent || '';
      // Match action keys like [1], [2], [N], [S], [I], [R], [H]
      var match = text.match(/\[([1-9A-Za-z])\]/);
      if (!match) return;
      var key = match[1].toLowerCase();
      document.dispatchEvent(new KeyboardEvent('keydown', {
        key: key,
        code: 'Key' + key.toUpperCase(),
        bubbles: true
      }));
    }

    document.addEventListener('click', function(e) {
      handleClickOrTap(e.clientX, e.clientY);
    });

    document.addEventListener('touchstart', function(e) {
      if (e.touches.length > 0) {
        var touch = e.touches[0];
        handleClickOrTap(touch.clientX, touch.clientY);
      }
    }, { passive: true });
  </script>
</html>
