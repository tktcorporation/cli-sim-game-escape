<!doctype html>
<html lang="ja">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
    <link data-trunk rel="rust" />
    <title>Idle Games - 放置ゲーム</title>
    <style>
      body {
        margin: 0;
        width: 100%;
        height: 100vh;
        height: 100dvh;
        background-color: #0a0a0a;
        overflow: hidden;
        touch-action: manipulation;
        -webkit-tap-highlight-color: transparent;
      }
      body > div {
        margin: 0;
        width: 100%;
      }
      pre {
        font-family: "Fira Code", "Courier New", monospace;
        font-size: 14px;
        /* Ratzilla sets inline height:15px which clips text when font is
           scaled up.  Let the row height follow the actual font size. */
        height: auto !important;
        line-height: 1.15;
        margin: 0;
        padding: 0;
        touch-action: manipulation;
        cursor: default;
      }
    </style>
  </head>
  <body></body>
  <script>
    // Reduce the viewport dimensions reported to Ratzilla so it calculates
    // fewer terminal columns/rows, resulting in larger text that fills the
    // real viewport via the fitGridToViewport scaler below.
    // SCALE_W < 1 → bigger text.  0.85 ≈ 18 % larger characters.
    (function() {
      var SCALE_W = 0.85;

      // Capture originals before any overrides.
      var origW = window.innerWidth || screen.width || 375;
      var origH = window.innerHeight || screen.height || 667;

      // Estimate how many rows will fit after font-width scaling.
      // Ratzilla: cols ≈ floor(scaledWidth / 10), assumes 15px/row.
      // fitGridToViewport scales font by: realWidth / gridContentWidth.
      // gridContentWidth ≈ cols × charWidth (monospace char ≈ 8.4px at 14px).
      // After scaling, row height = baseFontSize × fontScale × lineHeight.
      var cols = Math.floor(origW * SCALE_W / 10);
      var charWidth = 8.4;
      var fontScale = origW / (cols * charWidth);
      var rowHeight = 14 * fontScale * 1.15;
      var maxRows = Math.floor(origH / rowHeight);
      // Ratzilla creates rows = floor(innerHeight / 15).
      // SCALE_H gives us exactly maxRows.
      var SCALE_H = Math.min((maxRows * 15) / origH, SCALE_W);

      function overrideWith(obj, proto, prop, scale) {
        var desc = Object.getOwnPropertyDescriptor(proto, prop);
        if (desc && desc.get) {
          var orig = desc.get;
          Object.defineProperty(obj, prop, {
            get: function() { return Math.floor(orig.call(obj) * scale); },
            configurable: true
          });
        }
      }

      // Width: fixed scale for bigger font.
      // Height: computed scale so rows × scaled-row-height ≈ viewport height.
      overrideWith(window, Window.prototype, 'innerWidth', SCALE_W);
      overrideWith(window, Window.prototype, 'innerHeight', SCALE_H);
      overrideWith(screen, Screen.prototype, 'width', SCALE_W);
      overrideWith(screen, Screen.prototype, 'height', SCALE_H);
    })();
  </script>
  <script>
    // Ratzilla calculates terminal columns as screen_width/10 (mobile) or
    // window.innerWidth/10 (desktop), assuming ~10px per character. When the
    // actual rendered character width differs from 10px the grid becomes
    // narrower than the viewport. This observer waits for Ratzilla to mount
    // its grid, measures the real content width, and scales the font so the
    // grid fills the viewport exactly.
    (function() {
      var applied = false;
      var lastViewportWidth = 0;

      function fitGridToViewport() {
        var grid = document.getElementById('grid') || document.querySelector('body > div');
        if (!grid) return false;
        var pre = grid.querySelector('pre');
        if (!pre) return false;

        var viewportWidth = document.documentElement.clientWidth;

        // <pre> is a block element so scrollWidth always equals the
        // container width, not the actual text width.  Temporarily switch
        // to inline-block so the element shrink-wraps to its content,
        // then measure with getBoundingClientRect for sub-pixel accuracy.
        pre.style.display = 'inline-block';
        var contentWidth = pre.getBoundingClientRect().width;
        pre.style.display = '';

        if (contentWidth <= 0 || contentWidth >= viewportWidth) return true;

        var currentFontSize = parseFloat(getComputedStyle(pre).fontSize);
        var scaledFontSize = Math.floor(currentFontSize * (viewportWidth / contentWidth) * 100) / 100;
        var preElements = document.querySelectorAll('pre');
        for (var i = 0; i < preElements.length; i++) {
          preElements[i].style.fontSize = scaledFontSize + 'px';
        }

        applied = true;
        lastViewportWidth = viewportWidth;
        return true;
      }

      // Observe DOM for Ratzilla grid mount, then fit once.
      var observer = new MutationObserver(function() {
        if (fitGridToViewport()) observer.disconnect();
      });
      observer.observe(document.body, { childList: true, subtree: true });

      // Re-fit on orientation change or resize (debounced).
      var resizeTimer;
      window.addEventListener('resize', function() {
        clearTimeout(resizeTimer);
        resizeTimer = setTimeout(function() {
          var vw = document.documentElement.clientWidth;
          if (vw !== lastViewportWidth) {
            // Reset to CSS default so measurement is from a clean state.
            var preElements = document.querySelectorAll('pre');
            for (var i = 0; i < preElements.length; i++) {
              preElements[i].style.fontSize = '';
            }
            applied = false;
            // Allow one frame for layout, then re-measure.
            requestAnimationFrame(function() { fitGridToViewport(); });
          }
        }, 150);
      });
    })();

    // Touch handler: convert touch events to synthetic mousedown events.
    // This lets Ratzilla's on_mouse_event handler (registered in Rust) process
    // taps through the same ClickState hit-test path as desktop clicks.
    //
    // We dispatch a synthetic mousedown instead of handling touch in WASM because
    // web-sys TouchEvent/Touch/TouchList causes iOS Safari's WebKit WASM engine
    // to render a black screen (discovered in commit 0caf982).
    (function() {
      document.addEventListener('touchstart', function(e) {
        if (e.touches.length === 0) return;
        var touch = e.touches[0];
        // Prevent the browser from also generating mouse events from this touch.
        // Without this, Ratzilla's on_mouse_event fires twice per tap: once for
        // our synthetic mousedown and once for the browser's compatibility event.
        e.preventDefault();
        // Dispatch a synthetic mousedown so Ratzilla's on_mouse_event fires
        document.dispatchEvent(new MouseEvent('mousedown', {
          clientX: touch.clientX,
          clientY: touch.clientY,
          button: 0,
          bubbles: true
        }));
      }, { passive: false });
    })();
  </script>
</html>
